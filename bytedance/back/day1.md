## DAY1
### Client使用Https协议访问网站进行通信
#### 概念
1. HTTP协议（HyperText Transfer Protocol，超文本传输协议）  
    HTTP是客户端浏览器或其它程序与Web服务器之间的应用层通信协议
2. HTTPS协议（HyperText Transfer Protocol over Secure Socket Layer）  
    HTTPS可以理解为HTTP+SSL/TLS，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL，用于安全的HTTP数据传输
3. SSL（Secure Socket Layer，安全套接字层）  
    SSL于1994年由Netscape研发，SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持
4. TLS（Transport Layer Security，传输层安全）  
    TLS其前身是SSL，它最初的几个版本（SSL 1.0、SSL2.0、SSL3.0）由网景公司开发，1999年从3.1开始被IETF标准化并改名，发展至今已经有TLS 1.0、TLS 1.1、TLS 1.2三个版本。SSL3.0和和TLS1.0由于存在安全漏洞，已经很少被使用到

#### 加密算法
1. 对称加密  
    有流式、分组加密模式等，对称加密算法的特点是加密和解密使用相同的密钥，加密和解密速度快，但是密钥管理比较困难，密钥分发和管理成为了对称加密算法的瓶颈，因为密钥是需要分发给所有的参与者的，如果密钥被泄露，那么整个系统的安全性就会受到威胁  
    例如：DES、AES-GCM、ChaCha20-Poly1305等
2. 非对称加密  
    有公钥、私钥两种，公钥和私钥是一对，公钥加密的数据只有私钥才能解密，私钥加密的数据只有公钥才能解密，加密和解密的速度慢，但是密钥的分发和管理是一个非常简单的事情，因为密钥是不需要分发给所有的参与者的，只需要分发给加密方和解密方即可，如果密钥被泄露，那么只有加密方的安全性受到威胁，解密方的安全性不会受到威胁  
    例如：RSA、DSA、ECDSA、 DH、ECDHE 
3. 哈希算法  
    将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。哈希算法的特点是不可逆，即使知道了哈希算法，也无法通过哈希值反推出原始的信息，因此哈希算法也被称为单向散列函数  
    例如：MD5、SHA-1、SHA-256、SHA-512等
4. 数字签名  
    数字签名是一种类似于公章的机制，它可以用来验证数据的完整性和真实性，也可以用来验证数据的发送者和接收者。数字签名的特点是不可伪造，即使知道了签名算法，也无法通过签名值反推出原始的信息。  
    签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过。hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改。接收方收到信息后，会先对信息进行hash，然后用发送方的公钥解密签名，得到hash值，然后比较两个hash值是否一致，一致则说明信息没有被修改过，否则说明信息被修改过了。  
 
#### HTTPS的实现过程
整体过程分为证书验证和数据传输阶段
1. 证书验证阶段
   - 浏览器发起HTTPS请求
   - 服务端返回SSL/TLS证书
   - 客户端验证证书是否合法，如果不合法则发出警告
   
   **在证书验证阶段使用的是非对称加密**
2. 数据传输阶段
    - 当证书验证合法后，在本地生成随机数
    - 通过本地的公钥加密随机数，并把加密后的随机数传输到服务端
    - 服务端通过私钥对随机数进行解密
    - 服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输

    **在数据传输阶段使用的是对称加密**

### 操作系统中堆和栈的区别
堆和栈是两种内存分配的统称
#### 栈
- 栈用于存放函数的局部变量、返回地址等，具有LIFO（后进先出）的特点
- 栈由操作系统分配，自动回收
- 栈的大小受到一定的限制。在x86架构下，一般使用esp指向栈帧顶部，使用ebp指向栈帧底部（esp和ebp是汇编语言中的关键词）
- 不断嵌套或者为局部变量分配空间，可能会导致栈溢出，引起异常
- 每执行完一个函数，其中的变量都会从堆栈中弹出
- 栈的内存不需要手动管理，变量可以自动分配和释放
- 栈一般是高地址向低地址扩展，函数返回时会释放原来位置的空间
- 栈对应的是CPU的一级缓存，一级缓存在CPU内部，访问快，但是空间小

#### 堆
- 堆是不会被CPU自动管理的内存区域，在内存是自由浮动的区域
- 可以通过一些封装好的函数手动进行内存分配
- 在内核中使用brk指针指向堆的顶部，将堆视为大小不同的块的集合来维护。每一个块就是一个连续的虚拟内存，已经分配的块显式地保留供应用程序使用，空闲块可以自由分配内存
- 堆是从低地址向高地址扩展，是不连续的内存区域，通过链表来存储空闲内存地址
- 一般堆的头部用一个字节表示存放堆的大小
- 堆一般是二级缓存，为于CPU和内存之间的地址，访问慢于一级缓存，但比读取内存快，且空间容量较大
- 在多线程下，每个线程有各自的栈，并相互共享创建它们的进程的堆
- 堆分配的内存必须进行手动释放

#### 对比
1. 增长方向不同
    - 对于堆，增长方向向着内存地址增加的方向增长（低地址向高地址）
    - 对于栈，增长方向向着内存地址减小的方向增长（高地址向低地址）
2. 空间大小不同
    - 对于堆，堆内存可以有几G的空间
    - 对于栈，栈内存受到限制，一般只有相对固定的空间大小
3. 分配方式不同
    - 对于堆，堆内存都是在运行期动态分配的，没有在编译期静态分配的堆
    - 对于栈，栈内存有两种分配方式，静态分配和动态分配，其中动态分配可通过函数实现，释放的时候还是由编译器自动释放
4. 管理方式不同
    - 对于堆，分配释放工作需要设计程序手动操作，容易造成内存泄露
    - 对于栈，分配释放由编译器自动管理
5. 分配效率不同
    - 对于堆，堆是C/C++库函数提供的，效率要低于栈
    - 对于栈，栈也是C/C++库函数，但计算机底层对栈提供了一定的支持，有专门的寄存器来存放栈的地址，有专门的底层指令来执行入栈出栈，决定其效率要高于堆
6. 碎片问题
    - 对于堆，频繁的分配和释放会造成内存空间的不连续，产生大量的碎片，降低空间利用效率
    - 对于栈，不存在碎片问题，由操作系统自动回收