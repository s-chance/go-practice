## DAY6
### 关于MD5
MD5是一种不可逆的信息摘要算法，即无法通过密文还原明文，只能通过碰撞得到明文。碰撞就是指不同的密码通过MD5计算出了相同结果，都能通过验证。  
按现在的定义，加密算法必须要有对应的解密算法，所以严格来说MD5不能算是现代意义上的加密算法  
因此
- MD5不能用于加密密码，密码在通过MD5计算后已经无法恢复到原来的密码，MD5校验本质上是用明文去碰撞出一个相同结果
- MD5是不可逆的
- 对于不同的输入，MD5有可能会输出相同的结果
- 对于不同长度的输入，MD5计算结果的长度也不一定相同

### 关于红黑树
红黑树是一种含有红黑节点并能自平衡的二叉查找树。它必须满足以下性质
1. 每个节点只能是红色和黑色中的一种  
2. 根节点是黑色
3. 每个叶子节点是黑色
4. 每个红色节点的两个子节点一定都是黑色  
5. 任意节点到每个叶子节点的路径都包含数量相同的黑节点
6. 由5推出，一个节点存在黑色子节点，则该节点一定有两个子节点  

自平衡实现  
1. 左旋：以某个节点作为支点或旋转节点，其右子节点变为旋转节点的父节点，右子节点的左子节点变为旋转节点的右子节点，左子节点不受影响
2. 右旋：以某个节点作为支点或旋转节点，其左子节点变为旋转节点的父节点，左子节点的右子节点变为旋转节点的左子节点，右子节点不受影响
3. 变色：节点的颜色在红黑之间切换

查找实现
1. 从根节点开始查找，根节点设置为当前节点
2. 若当前节点为空，返回null
3. 若当前节点不为空，比较当前节点的key和要查找的key
4. 若当前节点key等于查找key，则返回当前节点
5. 若当前节点key大于查找key，当前节点设置为当前节点的左子节点，重复判断步骤
6. 若当前节点key小于查找key，当前节点设置为当前节点的右子节点，重复判断步骤  

红黑树的性质使其查找最坏情况下时间复杂度为O(2*log n)

插入实现
1. 从根节点开始查找
2. 若根节点为空，把插入节点作为根节点，结束
3. 若根节点不为空，把根节点作为当前节点
4. 若当前节点为null，返回当前节点的父节点，结束
5. 若当前节点key等于查找key，该key所在节点就是插入节点，更新节点的值，结束
6. 若当前节点key大于查找key，把当前节点的左子节点设置为当前节点，重复判断步骤
7. 若当前节点key小于查找key，把当前节点的右子节点设置为当前节点，重复判断步骤

一般情况下插入节点总是红色，因为红色不会破环黑色平衡，如果插入节点是黑色必然引起自平衡行为

插入情况分析
1. 红黑树为空树：直接把插入节点作为根节点，插入节点设置为黑色
2. 插入节点的key已存在：把当前节点的值更新为插入节点的值，插入节点的颜色设置为当前节点颜色
3. 插入节点的父节点P为黑节点：直接插入节点，默认红节点
4. 插入节点的父节点P为红节点  
   根据红黑树性质2，P不可能是根节点，因此插入节点总是存在祖父节点
   1. 叔叔节点S存在且为红节点：由于红黑树性质4，红红不能相连，因此将P和S设置为黑色，将它们的父节点PP设置为红色并设置为当前插入节点  
      如果PP的父节点为黑色，那么不需要再做任何处理，如果PP的父节点为红色，则还需要把PP视为新的插入节点继续做自平衡处理，直到平衡为止  
      如果PP为根节点，则PP还需要重新设置为黑色。这是唯一一种会增加黑色节点层数的情况
   2. 叔叔节点S不存在或为黑节点，且插入节点的父节点P是祖父节点的左子节点  
      S非红即为叶子节点，而P为红节点，如果S为黑节点且不为叶子节点，那么S所在子树的黑节点就比P所在子树的多，这不满足红黑树性质5
      1. 插入节点是其父节点的左子节点：将P设置为黑色，将其父节点PP设置为红色，对PP进行右旋。（这里可以反过来设置颜色，但是又会进入4.1的情况，增加了原本可以避免的操作）
      2. 插入节点是其父节点的右子节点：对P进行左旋操作，并将P设置为插入节点，转换为4.2.1的情况，按照4.2.1的情况进行处理即可
   3. 叔叔节点S不存在或为黑节点，且插入节点的父节点P是祖父节点的右子节点
      1. 插入节点是其父节点的右子节点：将P设置为黑色，将其父节点PP设置为红色，对PP进行左旋
      2. 插入节点是其父节点的左子节点：对P进行右旋操作，并将P设置为插入节点，转换为4.3.1的情况，按照4.3.1的情况进行处理即可

删除实现
1. 查找目标节点，复用查找操作。当目标节点不存在时，忽略本次操作，当目标节点存在时，进行删除操作
2. 删除后自平衡，寻找节点替代删除节点的位置，若删除节点刚好不存在子节点则不需要替代  
   
寻找替代节点
1. 删除节点无子节点，直接删除  
   删除节点被替代后，在不考虑节点键值的情况下，对于树来说，可认为删除的是替代节点。这是在删除节点后为了保持原有树结构完整的结果，因此所有的删除情况最终都可以转换为1的情况
2. 删除节点只有一个子节点，用该子节点替代删除节点的位置  
   删除节点用唯一的子节点替换，子节点替换为删除节点后，可认为删除的是子节点，若子节点又有两个子节点，则转换为3的情况，自顶向下处理，直到转换为情况1
3. 删除节点有两个子节点，用后继节点（大于删除节点的最小节点，即删除节点的右子树的最左节点）替代删除节点的位置。（理论上也可以用前继节点，即删除节点的左子树的最右节点。习惯上是使用后继节点）  
   删除节点后用后继节点，后继节点已经是最左子节点，不可能还有还有左子节点，如果后继节点存在右子节点，则转换为情况2，否则转换为情况1  
删除节点实际上可以视为删除替代节点的操作，而替代节点最后都会转换为叶子节点

删除情况分析
1. 替代节点R是红节点：将替代节点的颜色设置为删除节点的颜色
2. 替代节点R是黑节点
   1. 替代节点R是其父节点P的左子节点
      1. 替代节点R的兄弟节点S是红节点：根据红黑树性质4，兄弟节点的父节点和子节点一定为黑节点，将兄弟节点S设置为黑色，将父节点P设置为红色，对父节点P进行左旋操作，转换为情况2.1.2.3处理
      2. 替代节点R的兄弟节点S是黑节点
         1. 替代节点R的兄弟节点S的右子节点SR是红节点：将S的颜色设置为P的颜色，将P设置为黑色，将SR设置为黑色，对P进行左旋操作
         2. 替代节点R的兄弟节点S的右子节点SR是黑节点，左子节点SL是红节点：将S设置为红色，将SL设置为黑色，对S进行右旋操作，转换为情况2.1.2.1处理
         3. 替代节点R的兄弟节点S的子节点都是黑节点：将S设置为红色，将P作为新的替代节点，重新进行删除节点的情况处理
   2. 替代节点R是其父节点P的右子节点
      1. 替代节点R的兄弟节点S是红节点：将S设置为黑色，将P设置为红色，对P进行右旋，转换为情况2.2.2.3处理
      2. 替代节点R的兄弟节点S是黑节点
         1. 替代节点R的兄弟节点S的左子节点SL是红节点：将S的颜色设置为P的颜色，将P设置为黑色，将SL设置为黑色，对P进行右旋操作
         2. 替代节点R的兄弟节点S的左子节点SL是黑节点，右子节点SL是红节点：将S设置为红色，将SR设置为黑色，对S进行左旋操作，转换为情况2.2.2.1处理
         3. 替代节点R的兄弟节点S的子节点都是黑节点：将S设置为红色，将P作为新的替代节点，重新进行删除节点的情况处理

因此  
- 红黑树任意两个子树的高度差是不确定的，只要能保持整体平衡即可
- 红黑树从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑色节点
- 红黑树插入节点时最多经过3次旋转达到平衡
- 红黑树进行插入操作时需要解决红红冲突