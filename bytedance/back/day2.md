## DAY2
### Go中关于整型切片的初始化
```go
// 方式一：直接指定切片元素
// 长度和容量根据指定的元素自动推断
s := []int{1,2,3,4,5}

// 方式二：使用make函数初始化切片
// 有三个参数
// 第一个是数据类型
// 第二个是切片长度
// 第三个是切片容量（可缺省，缺省时默认容量等于长度）
s := make([]int,5)
s := make([]int,5,10)
```


### 可能触发本地CPU cache失效的操作
#### 缓存一致性
在多核CPU中，内存数据会在多个核心中存在数据副本。当修改其中一个核心时，就会与其它核心产生数据不一致的问题。因此，需要缓存一致性协议保证多个CPU cache之间缓存共享数据的一致性
#### MESI协议
MESI协议就是基于缓存一致性的协议之一  
**cache的写方式**
- write through（写通）：每次修改CPU cache的数据，立即更新到内存中。这意味着每次CPU写共享数据都会触发总线事务，这种方式容易引起总线事务竞争，能够保持高一致性，但是效率非常低
- write back（写回）：每次修改CPU cache的数据，不会立即更新到内存，而是等待cache line的某一个必须或合适的时机才会更新到内存中  
无论是哪种写方式，在多线程环境下都需要处理缓存一致性问题。为了保持缓存一致性，处理器又提供了两个操作
- write invalidate（写失效）：当一个CPU修改了数据时，若其它CPU存在该数据，则通知其无效
- write update（写更新）：当一个CPU修改了数据时，若其它CPU存在该数据，则通知其更新数据  
写更新会导致大量数据操作，MESI协议中的I就代表了invalid，表示其采用的是写失效
**cache line的状态**
cache line是cache与内存进行数据交换的最小单位，一般是32或64字节。cache line在MESI协议中拥有以下状态（由M、E、S、I四个字母代表）
- modify（修改）：本地CPU cache拥有最新数据，其它CPU cache拥有失效数据。即使本地CPU中的数据与主存不一致，仍以本地CPU数据为准
- exclusive（独占）：只有本地CPU中有数据，其它CPU中没有该数据，本地CPU数据和主存数据是一致的
- shared（共享）：本地CPU和其它CPU都有共同数据，且和主存中的数据是一致的
- invalid（失效）：本地CPU中的数据失效，数据应该从主存中获取，其它CPU中可能有数据也可能没有数据，本地CPU数据和主存数据是不一致的  
以上四个状态都涉及到了CPU与主存的关系
**关于cache操作**  
在MESI协议中，每个cache的控制器不仅能够监听本地cache操作，也能监听其它CPU的cache操作，并根据情况调整各自cache中共享数据的状态
- local read（LR）：本地读取
- local write（LW）：本地写入
- remote read（RR）：远端读取
- remote write（RW）：远端写入
#### 引起本地CPU cache失效
以下需要从不同的工作状态场景下考虑
##### modify状态（M）
前提：本地CPU中拥有最新数据，虽然主存中的数据和本地CPU中的数据不一致，但是以本地CPU中的数据为准  
- LR：直接从本地cache中获取数据，状态不变
- LW：直接修改本地cache数据，状态不变
- RR：从远端cache中获取数据，因为本地cache拥有最新数据，远端cache会通过主存与本地cache同步，状态更新为S
- RW：修改远端cache数据，会写回主存数据，本地cache数据和主存数据不一致，状态变为I
##### exclusive状态（E）
前提：本地CPU独占数据（其他CPU没有数据），并且和主存的数据一致  
- LR：直接从本地cache中获取数据，状态不变
- LW：修改本地cache数据，状态变为M（由于其它CPU中没有数据，因此没有共享问题，不需要通知其它CPU修改cache line的状态为I）
- RR：远端cache会从主存中获取数据，且此时本地cache与主存数据一致，因此状态变为S
- RW：修改远端cache数据，会写回主存数据，此时为了保持缓存一致性，本地cache的状态变为I
##### shared状态（S）
前提：本地CPU和其他CPU共享数据，且数据在多个CPU之间一致、多个CPU之间的数据和主存一致  
- LR：直接从本地cache中获取数据，状态不变
- LW：修改本地cache数据，由于不会立即写回到主存中，本地cache状态变为M，并通知其它CPU修改cache line的状态为I
- RR：因为多个CPU中的数据和主存一致，所以状态不变
- RW：远端cache数据被修改，且写回到主存中，此时本地cache不再是最新数据，和主存数据也不一致，状态变为I
##### invalid状态（I）
前提：本地CPU中是脏数据，不可用，其他CPU可能有数据、也可能没有数据
- LR：因为本地cache不可用，于是会读取内存，发生以下情况
  - 如果其它CPU中无数据，则本地cache状态变为E
  - 如果其它CPU中有数据且状态为S或E则本地cache状态变为S
  - 如果其它CPU中有数据且状态为M，则会执行RW操作将远端cache数据写回主存并更新状态为S，随后本地cache读取主存数据，状态也更新为S
- LW：直接操作本地cache，发生以下情况
  - 如果其它CPU中无数据，则本地cache状态变为M
  - 如果其它CPU中有数据且状态为S或E，则修改本地cache，通知其它CPU的状态更新为I，本地CPU状态更新为M
  - 如果其它CPU中有数据且状态为M，则其它CPU先将数据写回主存，并更新状态为I，本地cache状态更新为M
- RR：其它CPU读取主存，与本地cache无关，状态不变
- RW：其它CPU写回主存，与本地cache无关，状态不变
